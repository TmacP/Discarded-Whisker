-- card_factory.script

local debugPlayer = false
local debugAi = false
local debugBattle = true
local debuganimatePlayers = true

local players_turn = nil

local card_data = require "Scripts.cards.card_data"
local playerModule = require "Scripts.player"

local spawned_cards = {} -- keep track of what the factory creates
local elements = {} -- keep track of the elements on the board

local rounds = 1
local y = 29
local x = 55
local card_object = nil

local currentPlayer = playerModule.create()  -- Create a player instance
local ai = playerModule.create() -- create an ai opponent

local original_position = vmath.vector3()

function init(self)

	
	player_turn(self)
	-- show the deck of cards
	local p_deck = go.get_position()
	p_deck.x = 20 -- Set the desired x-coordinate
	p_deck.y = 29 -- Set the desired y-coordinate
	card_object = factory.create("#factory", p_deck, nil, {name = hash("Deck")})
end



function player_turn(self)

	print("-------------------- ROUND " .. tostring(rounds))
	if debugPlayer then print("-- player's turn begins") end

	-- player draws card from their deck into their hand
	local drawnCard = playerModule.drawCard(currentPlayer)

	if drawnCard then    
		if debugPlayer then print("-- Drawing card from player's deck: " .. drawnCard.name) end
		local cardProperties = { name = hash(drawnCard.name) }

		-- Set the initial position for the card at the deck
		local deckPosition = go.get_position()
		deckPosition.x = 20
		deckPosition.y = 29
		
		local cardObject = factory.create("#factory", deckPosition, nil, cardProperties)
		
		table.insert(spawned_cards, {[cardObject] = drawnCard.name})

		-- Set the final position for the card at the player's hand
		local playerHandPosition = go.get_position()
		playerHandPosition.x = x
		playerHandPosition.y = y

		-- Tween the card from the deck to the player's hand
		go.animate(cardObject, "position", go.PLAYBACK_ONCE_FORWARD, playerHandPosition, go.EASING_LINEAR, 0.5, 0)
		x = x + 35
	else
		if debugPlayer then print("-- No cards left in the player's deck. Or hand has 7 cards") end
	end

	if debugPlayer then print("-- if deck is empty remove it") end
	if #currentPlayer.deck == 0 then
		if debugPlayer then print("player deck is " .. #currentPlayer.deck) end
		go.set_scale(0.01, card_object)
	end

	-- Print the player's hand
	if debugPlayer then
		local hand = "-- Player's hand:"
		for _, card in ipairs(currentPlayer.hand) do
			hand = hand .. " " .. card.name
		end
		print(hand)
	end

	-- now the player gets to play a card from their hand
	players_turn = true
end



function ai_turn(self)
	players_turn = false
	if debugAi then print("--------------------") end
	if debugAi then print("-- ai's turn begins") end
	local drawnCard = playerModule.drawCard(ai)

	if drawnCard then
		if debugAi then print("-- Drawing card from ai's deck: " .. drawnCard.name) end

		-- AI plays the first card from its hand into playzone
		local aiCard = table.remove(ai.hand, 1)
		table.insert(ai.playzone, aiCard)
		if aiCard then
			playerModule.playCard(ai, aiCard.name)
			if debugAi then print("ai playzone " .. #ai.playzone) end
			element(aiCard.name, true, "ai", #ai.playzone)  -- Create the corresponding element
	end
	else
		if debugAi then print("-- No cards left in the ai's deck.") end 
	end

	rounds = rounds + 1
	 if debugAi then print("-- ai's turn ends") end
	if debugAi then print("") end

	battle(self)
end




function battle(self)
	if debugBattle then print("function battle(self)") end

	local animations = {
		{team = "player", position = 1},
		{team = "ai", position = 1},
		{team = "player", position = 2},
		{team = "ai", position = 2},
		{team = "player", position = 3},
		{team = "ai", position = 3},
	}

	-- Start the first animation in the chain
	playNextAnimation(animations, 1)
end

function playNextAnimation(animations, index)
	if index > #animations then
		-- All animations are done
		player_turn(self)
		return
	end

	local animation = animations[index]
	animatePlayers(elements, animation.team, animation.position, function() 
		-- Callback for the current animation
		print("Animation complete for team:", animation.team, "position:", animation.position)

		-- Start the next animation in the chain
		playNextAnimation(animations, index + 1)
	end)
end

function animatePlayers(elements, team, position, callback)
	local found = false
	for i, v in pairs(elements) do
		local object = nil
		local t = nil
		local p = nil
		for key, value in pairs(v) do
			if key == "Team" and value == team then
				t = value
			end
			if key == "Id" then
				object = value
			end
			if key == "Position" and value == position then
				p = value
			end
		end
		if p == position and t == team and object then
			found = true
			if debuganimatePlayers then
				print("-- found the position: " .. p .. " and the team: " .. t .. " and the object: " .. object)
			end
			-- Call player.takeDamage here
			if team == "player" then
				playerModule.takeDamage(currentPlayer, 1, "ai")  -- Replace damageAmount with the actual damage value
			elseif team == "ai" then
				playerModule.takeDamage(ai, 1, "player")  -- Replace damageAmount with the actual damage value
			end
			go.set(object, "position.y", 99)
			go.animate(object, "position.y", go.PLAYBACK_ONCE_PINGPONG, 109, go.EASING_INBOUNCE, 0.75, 0, callback)
			break -- Exit the loop once a valid animation is found
		end
	end

	if not found then
		-- If no valid animation is found, proceed to the next animation in the chain
		callback()
	end
end




function on_message(self, message_id, message, sender)
	if message_id == hash("end_turn_message")  and players_turn then
		-- Handle the message indicating the turn has ended
		if debugPlayer then print("-- Player's turn has ended.") end

		-- Separate if statement for handling "new_deck" message
		if #currentPlayer.deck == 0 then
			if debugPlayer then print("new") end
			-- if players deck is empty if so then shuffle discard and move to deck.
			playerModule.newDeck(currentPlayer)
			if debugPlayer then print("after newDeck " .. #currentPlayer.deck) end
			-- Restore the original position to make the card object visible
			go.set_position(original_position, card_object)
			x = 55
		end
		-- after player it is ai's turn
		ai_turn(self)
	end

	
		-- if the cursor sends the play card message we play the card and delete it
	if message_id == hash("play_card") then
		for message_id, card_info in pairs(spawned_cards) do
			--print("Message ID:", message_id)
			for card_key, card_value in pairs(card_info) do
				--print(card_key, "=", card_value)
				--print(card_key)
				--print(message[1])
				if message[1] == card_key then
					-- player plays card if they have room on playzone MAX 3 elements at time
					if #currentPlayer.playzone < 3 then

						playerModule.playCard(currentPlayer, card_value)
						if debugPlayer then print("playzone" .. #currentPlayer.playzone) end 
					-- put the element on the playboard
					element(card_value, false, "player", #currentPlayer.playzone)
					-- delete the card
					go.delete(message)
					end
				end
			end
		end
	end

end



function element(name, flip, team, position)
	--print("name of elemenet" .. name )	
	local cardProperties = { name = hash(name), flip = flip, team = hash(team), position = position }
	local id = factory.create("#element_factory", nil, nil, cardProperties )
	table.insert(elements, {Id = id, Name = name, Team = team, Position = position})
end


