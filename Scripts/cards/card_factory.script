-- card_factory.script

local debugPlayer = false
local debugAi = true

local card_data = require "Scripts.cards.card_data"
local playerModule = require "Scripts.player"

local spawned_cards = {} -- keep track of what the factory creates

local rounds = 1
local y = 29
local x = 55
local card_object = nil

local currentPlayer = playerModule.create()  -- Create a player instance
local ai = playerModule.create() -- create an ai opponent

local original_position = vmath.vector3()

function init(self)
	player_turn(self)
	-- show the deck of cards
	local p_deck = go.get_position()
	p_deck.x = 20 -- Set the desired x-coordinate
	p_deck.y = 29 -- Set the desired y-coordinate
	card_object = factory.create("#factory", p_deck, nil, {name = hash("Deck")})
end



function player_turn(self)
	print("-------------------- ROUND " .. tostring(rounds))
	if debugPlayer then print("-- player's turn begins") end

	-- player draws card from their deck into their hand
	local drawnCard = playerModule.drawCard(currentPlayer)

	if drawnCard then    
		if debugPlayer then print("-- Drawing card from player's deck: " .. drawnCard.name) end
		local cardProperties = { name = hash(drawnCard.name) }

		-- Set the initial position for the card at the deck
		local deckPosition = go.get_position()
		deckPosition.x = 20
		deckPosition.y = 29
		
		local cardObject = factory.create("#factory", deckPosition, nil, cardProperties)
		
		table.insert(spawned_cards, {[cardObject] = drawnCard.name})

		-- Set the final position for the card at the player's hand
		local playerHandPosition = go.get_position()
		playerHandPosition.x = x
		playerHandPosition.y = y

		-- Tween the card from the deck to the player's hand
		go.animate(cardObject, "position", go.PLAYBACK_ONCE_FORWARD, playerHandPosition, go.EASING_LINEAR, 0.5, 0, function()
			-- Callback function when the tween is complete
			-- You can add any additional logic here
		end)
		x = x + 35
	else
		if debugPlayer then print("-- No cards left in the player's deck. Or hand has 7 cards") end
	end

	if debugPlayer then print("-- if deck is empty remove it") end
	if #currentPlayer.deck == 0 then
		if debugPlayer then print("player deck is " .. #currentPlayer.deck) end
		-- Store the original position before moving off-screen
		original_position = go.get_position(card_object)
		-- Move the card object off-screen to make it invisible
		go.set_position(vmath.vector3(10000, 10000, 0), card_object)
		

	end

	-- Print the player's hand
	if debugPlayer then
		local hand = "-- Player's hand:"
		for _, card in ipairs(currentPlayer.hand) do
			hand = hand .. " " .. card.name
		end
		print(hand)
	end

	-- now the player gets to play a card from their hand

end



function ai_turn(self)
	print("--------------------")
	print("-- ai's turn begins")
	local drawnCard = playerModule.drawCard(ai)

	if drawnCard then
		print("-- Drawing card from ai's deck: " .. drawnCard.name)

		-- AI plays the first card from its hand into playzone
		local aiCard = table.remove(ai.hand, 1)
		table.insert(ai.playzone, aiCard)
		if aiCard then
			playerModule.playCard(ai, aiCard.name)
			print("ai playzone " .. #ai.playzone)
			element(aiCard.name, true, "ai", #ai.playzone)  -- Create the corresponding element
	end
	else
		print("-- No cards left in the ai's deck.")
	end

	rounds = rounds + 1
	print("-- ai's turn ends")
	print("")
	print("move in battle now")
	player_turn(self)
end

function on_message(self, message_id, message, sender)
	if message_id == hash("end_turn_message") then
		-- Handle the message indicating the turn has ended
		print("-- Player's turn has ended.")        

		-- Separate if statement for handling "new_deck" message
		if #currentPlayer.deck == 0 then
			print("new")
			-- if players deck is empty if so then shuffle discard and move to deck.
			playerModule.newDeck(currentPlayer)
			print("after newDeck " .. #currentPlayer.deck)
			-- Restore the original position to make the card object visible
			go.set_position(original_position, card_object)
			x = 55
		end
		-- after player it is ai's turn
		ai_turn(self)
	end

	
		-- if the cursor sends the play card message we play the card and delete it
	if message_id == hash("play_card") then
		for message_id, card_info in pairs(spawned_cards) do
			--print("Message ID:", message_id)
			for card_key, card_value in pairs(card_info) do
				--print(card_key, "=", card_value)
				--print(card_key)
				--print(message[1])
				if message[1] == card_key then
					-- player plays card if they have room on playzone MAX 3 elements at time
					if #currentPlayer.playzone < 3 then

						playerModule.playCard(currentPlayer, card_value)
						print("playzone" .. #currentPlayer.playzone)
					-- put the element on the playboard
					element(card_value, false, "player", #currentPlayer.playzone)
					-- delete the card
					go.delete(message)
					end
				end
			end
		end
	end
end



function element(name, flip, team, position)
	print("name of elemenet" .. name )	
	local cardProperties = { name = hash(name), flip = flip, team = hash(team), position = position }
	factory.create("#element_factory", nil, nil, cardProperties )
end